```Haskell
type Reader a x = a -> x
```
```kotlin:ank:silent
typealias Reader<D, A> = Kleisli<ForId, D, A>
```
................
```Haskell
instance Functor (Reader a) where
    fmap f h = f . h
```
```kotlin:ank:silent
fun <D, A> fmap(run: (D) -> A): Reader<D, A> = Kleisli(run.andThen { Id(it) })
```
................
```Haskell
type Op a x = x -> a
```
```kotlin:ank:silent
typealias Op<A, X> = (X) -> A
```
................
```Haskell
instance Contravariant (Op a) where
    contramap f h = h . f
```
```kotlin:ank:playground
import arrow.core.compose
 
data class Op<A, B> constructor(private val f: (A) -> B) {
   fun <C> contramap(op: Op<B, C>) = Op<A, C> { (op.f compose f)(it) }
}
```
................
```Haskell
instance Profunctor (->) where
    dimap ab cd bc = cd . bc . ab
    lmap = flip (.)
    rmap = (.)
```
```kotlin:ank:silent
import arrow.extension
import arrow.typeclasses.Profunctor
@extension
interface ArrowProfunctor: Profunctor<ForFunction1> {
    override fun <A, B, C, D> Kind2<ForFunction1, A, B>.dimap(fl: (C) -> A, fr: (B) -> D): Kind2<ForFunction1, C, D> =
        (fr compose fix().f compose fl).k()
 
    override fun <A, B, C> Kind2<ForFunction1, A, B>.lmap(f: (C) -> A): Kind2<ForFunction1, C, B> =
        (f andThen fix().f).k()
 
    override fun <A, B, D> Kind2<ForFunction1, A, B>.rmap(f: (B) -> D): Kind2<ForFunction1, A, D> =
        (fix().f andThen f).k()
}
```
................
```Haskell
alpha :: forall x. (a -> x) -> F x
```
```kotlin:kotlin
fun<A, F, G> alpha(): (Kind<F, A>) -> Kind<G, A>
```
................
```Haskell
fmap f . alpha = alpha . fmap f
```
```kotlin
fmap(f) compose alpha == alpha compose fmap(f)
```
................
```Haskell
fmap f (alpha h) = alpha (f . h)
```
```kotlin
fmap(f)(alpha(h)) == alpha(f compose h)
```
................
```Haskell
beta :: forall x. F x -> (a -> x)
```
```kotlin:ank:silent
fun<A, F, G> beta(): (Kind<F, A>) -> Kind<G, A>
```
................
```Haskell
alpha :: forall x. (Int -> x) -> [x]
alpha h = map h [12]
```
```kotlin
fun <A> alpha(h : (Int) -> A) = listOf(12).map(h)
```
................
```Haskell
map f (map h [12]) = map (f . h) [12]
```
```kotlin
fmap(f)(fmap(h)(listOf(12))) == fmap(f compose h)(listOf(12))
```
................
```Haskell
beta :: forall x. [x] -> (Int -> x)
```
```kotlin:ank:silent

```
................
```Haskell
class Representable f where
    type Rep f :: *
    tabulate :: (Rep f -> x) -> f x
    index    :: f x -> Rep f -> x
```
```kotlin:ank:silent
interface Representable<F, A> {
    fun <X>tabulate(f: (A) -> X): Kind<F, X>
    fun <X>index(f: Kind<F, X>): (A) -> X
}
```
................
```Haskell
data Stream x = Cons x (Stream x)
```
```kotlin:ank:silent
data class Stream<X>(val h: () -> X, val t: () -> Stream<X>) : Kind<ForStream, X>
```
................
```Haskell
instance Representable Stream where
    type Rep Stream = Integer
    tabulate f = Cons (f 0) (tabulate (f . (+1)))
    index (Cons b bs) n = if n == 0 then b else index bs (n - 1)
```
```kotlin:ank:silent
val streamRepresentable = object: Representable<ForStream, Int>{

    override fun <X> tabulate(f: (Int) -> X): Kind<ForStream, X> =
        Stream({f(0)}, {tabulate(f compose {x -> x + 1}).fix()})


    override fun <X> index(f: Kind<ForStream, X>): (Int) -> X {
        val (b, bs) = f.fix()
        return {n ->
            if(n == 0) b()
            else index(bs())(n - 1)
        }
    }

}
```
................
