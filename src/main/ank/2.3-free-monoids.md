```Haskell
class Monoid m where
  mempty :: m
  mappend :: m -> m -> m
```
```kotlin:ank:silent
package arrow.typeclasses

class ForMonoid private constructor() { companion object }
typealias MonoidOf<A> = arrow.Kind<ForMonoid, A>
fun <A> MonoidOf<A>.fix(): Monoid<A> = this as Monoid<A>

interface Monoid<A> : Semigroup<A>, MonoidOf<A> {
  fun empty(): A

  fun Collection<A>.combineAll(): A =
    if (isEmpty()) empty() else reduce { a, b -> a.combine(b) }

  fun combineAll(elems: List<A>): A = elems.combineAll()
  companion object
}
```
................
```Haskell
instance Monoid [a] where
  mempty = []
  mappend = (++)
```
```kotlin
package free

import arrow.higherkind
import arrow.typeclasses.Monoid

operator fun <A>FreeMonoid<A>.plus(b: FreeMonoid<A>) = FreeMonoid.just(this.terms + b.terms)

@higherkind
sealed class FreeMonoid<S>(val terms: List<S>): FreeMonoidOf<S> {

    internal data class Pure<A>(val a: List<A>) : FreeMonoid<A>(a)

    fun <A> run (f: (S) -> A) = {
       M:Monoid<A> -> M.combineAll(terms.map(f))
    }

    companion object {
        fun <A> mempty(): FreeMonoid<A> = Pure(listOf())
        fun <A> just(a: A): FreeMonoid<A> = Pure(listOf(a))
        fun <A> just(a: List<A>): FreeMonoid<A> = Pure(a)
    }
}

fun <A> freeMonoidMonoid(): Monoid<FreeMonoid<A>>  = object: Monoid<FreeMonoid<A>> {
    override fun FreeMonoid<A>.combine(y: FreeMonoid<A>): FreeMonoid<A> =
        FreeMonoid.just(this.terms + y.terms)

    override fun empty(): FreeMonoid<A> = FreeMonoid.mempty()
}
```
................
```Haskell
2 * 3 = 6
[2] ++ [3] = [2, 3] // not the same as [6]
```
```kotlin
2 * 3 = 6
FreeMonoid.just(2) + FreeMonoid.just(3) == FreeMonoid.just(listOf(2, 3)) // not the same as FreeMonoid.just(6)
```

................
```Haskell
h (a * b) = h a * h b
```
```kotlin
h(a * b) == h(a) * h(b)
```

................
```Haskell
[2] ++ [3] = [2, 3]
```
```kotlin
FreeMonoid.just(2) + FreeMonoid.just(3) == FreeMonoid.just(listOf(2, 3))
```

................
```Haskell
2 * 3 = 6
```
```kotlin:ank:silent
2 * 3 == 6
```
................
```Haskell
p :: x -> U m
```
```kotlin
val p : (X) -> Kind<U, M>
```

................
```Haskell
q :: x -> U n
```
```kotlin
val q: (X) -> Kind<U, N>
```

................
```Haskell
h :: m -> n
```
```kotlin
val h: (M) -> N
```

................
```Haskell
q = U(h) . p
```
```kotlin
val q = uh compose p
```
